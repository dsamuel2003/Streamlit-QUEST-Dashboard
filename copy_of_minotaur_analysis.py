# -*- coding: utf-8 -*-
"""Copy of minotaur analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QnylWsnL0ezRIhcnvioiJcE6Rae_KLP0
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

sns.set_style("whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)

from google.colab import files

uploaded = files.upload()
filename = list(uploaded.keys())[0]
df = pd.read_excel(filename)

print(f"Loaded {len(df):,} tickets")
df.head()

time_cols = ['SecInBacklog', 'SecBlocked', 'SecInProgress', 'SecReadyReview',
             'SecInReview', 'SecReadyForTest', 'SecInTest', 'SecInCI']

for col in time_cols:
    new_col = col.replace('Sec', 'days')
    df[new_col] = df[col] / 86400

df['totalCycleTime'] = df[[c for c in df.columns if c.startswith('days')]].sum(axis=1)

df['activeDevelopmentTime'] = (df['daysInProgress'] + df['daysInReview'] +
                                df['daysInTest'] + df['daysInCI'])

df = df.rename(columns={'Team ': 'Team'})

df['Created'] = pd.to_datetime(df['Created'])
df['Resolved'] = pd.to_datetime(df['Resolved'])

print("Basic Stats:")
print(f"  Total tickets: {len(df):,}")
print(f"  Date range: {df['Created'].min().date()} to {df['Created'].max().date()}")
print(f"  Average cycle time: {df['totalCycleTime'].mean():.1f} days")
print(f"  Median cycle time: {df['totalCycleTime'].median():.1f} days")
print(f"  Tickets in backlog: {len(df[df['Status'] == 'Backlog']):,}")
print(f"  Resolved tickets: {len(df[df['Status'] == 'Resolved']):,}")

stages = {
    'Backlog': df['daysInBacklog'].mean(),
    'In Progress': df['daysInProgress'].mean(),
    'Ready for Review': df['daysReadyReview'].mean(),
    'In Review': df['daysInReview'].mean(),
    'Ready for Test': df['daysReadyForTest'].mean(),
    'In Test': df['daysInTest'].mean(),
    'In CI': df['daysInCI'].mean(),
    'Blocked': df['daysBlocked'].mean()
}

stages_sorted = dict(sorted(stages.items(), key=lambda x: x[1], reverse=True))

total_time = sum(stages_sorted.values())
print("Average time in each stage:")
for stage, days in stages_sorted.items():
    pct = (days / total_time * 100)
    print(f"  {stage:20s} {days:6.1f} days ({pct:4.1f}%)")

fig = go.Figure(go.Waterfall(
    orientation = "v",
    measure = ["relative"] * len(stages_sorted),
    x = list(stages_sorted.keys()),
    y = list(stages_sorted.values()),
    text = [f"{v:.1f}d" for v in stages_sorted.values()],
    textposition = "outside",
    connector = {"line":{"color":"rgb(63, 63, 63)"}},
))

fig.update_layout(
    title="Cycle Time Breakdown",
    showlegend=False,
    height=500,
    yaxis_title="Days"
)
fig.show()

fig = px.pie(values=list(stages_sorted.values()),
             names=list(stages_sorted.keys()),
             title='Time Distribution by Stage')
fig.update_traces(textposition='inside', textinfo='percent+label')
fig.show()

print("Stage Duration by Type and Priority")
print("=" * 60)

stage_cols = ['daysInBacklog', 'daysInProgress', 'daysReadyReview', 'daysBlocked',
              'daysInCI', 'daysInTest', 'daysInReview', 'daysReadyForTest']

df['Priority_clean'] = df['Priority'].str.strip()

heatmap_data = []
for ticket_type in df['Type'].unique():
    for priority in sorted(df['Priority_clean'].unique()):
        subset = df[(df['Type'] == ticket_type) & (df['Priority_clean'] == priority)]
        if len(subset) > 0:
            for stage_col in stage_cols:
                stage_name = stage_col.replace('days', '').replace('In', ' ').strip()
                heatmap_data.append({
                    'Type': ticket_type,
                    'Priority': priority,
                    'Stage': stage_name,
                    'Days': subset[stage_col].mean(),
                    'Count': len(subset)
                })

heatmap_df = pd.DataFrame(heatmap_data)

pivot_data = heatmap_df.pivot_table(
    values='Days',
    index='Stage',
    columns=['Type', 'Priority'],
    aggfunc='mean'
)

fig = go.Figure(data=go.Heatmap(
    z=pivot_data.values,
    x=[f"{t}<br>{p}" for t, p in pivot_data.columns],
    y=pivot_data.index,
    colorscale='YlOrRd',
    text=np.round(pivot_data.values, 1),
    texttemplate='%{text}d',
    textfont={"size": 10},
    colorbar=dict(title="Days")
))

fig.update_layout(
    title='Average Stage Duration by Ticket Type and Priority',
    xaxis_title='Type & Priority',
    yaxis_title='Stage',
    height=500,
    width=1200
)
fig.show()

print("\nKey Insights:")
for ticket_type in df['Type'].unique():
    type_data = heatmap_df[heatmap_df['Type'] == ticket_type]
    slowest_stage = type_data.groupby('Stage')['Days'].mean().idxmax()
    slowest_days = type_data.groupby('Stage')['Days'].mean().max()
    print(f"  {ticket_type}: Slowest stage is '{slowest_stage}' ({slowest_days:.1f} days avg)")

print("\n" + "=" * 60)
print("Stage Breakdown Comparison by Ticket Type")
print("=" * 60)

type_comparisons = {}
for ticket_type in df['Type'].unique():
    type_df = df[df['Type'] == ticket_type]
    type_comparisons[ticket_type] = {
        'Backlog': type_df['daysInBacklog'].mean(),
        'In Progress': type_df['daysInProgress'].mean(),
        'Ready for Review': type_df['daysReadyReview'].mean(),
        'In Review': type_df['daysInReview'].mean(),
        'Ready for Test': type_df['daysReadyForTest'].mean(),
        'In Test': type_df['daysInTest'].mean(),
        'In CI': type_df['daysInCI'].mean(),
        'Blocked': type_df['daysBlocked'].mean()
    }
    type_comparisons[ticket_type] = dict(sorted(
        type_comparisons[ticket_type].items(),
        key=lambda x: x[1],
        reverse=True
    ))

fig = make_subplots(
    rows=1, cols=3,
    subplot_titles=[f'{t} (n={len(df[df["Type"]==t]):,})' for t in df['Type'].unique()],
    specs=[[{"type": "bar"}, {"type": "bar"}, {"type": "bar"}]]
)

colors = ['#2E7D32', '#1976D2', '#D32F2F']

for idx, (ticket_type, color) in enumerate(zip(df['Type'].unique(), colors)):
    stages = list(type_comparisons[ticket_type].keys())
    values = list(type_comparisons[ticket_type].values())

    fig.add_trace(
        go.Bar(
            x=stages,
            y=values,
            marker_color=color,
            text=[f'{v:.1f}d' for v in values],
            textposition='outside',
            name=ticket_type,
            showlegend=False
        ),
        row=1, col=idx+1
    )

    total = sum(values)
    print(f"\n{ticket_type}:")
    for stage, days in type_comparisons[ticket_type].items():
        pct = (days / total * 100) if total > 0 else 0
        print(f"  {stage:20s} {days:6.1f} days ({pct:4.1f}%)")

fig.update_layout(
    title_text="Stage Duration by Ticket Type",
    height=500,
    showlegend=False
)

for i in range(1, 4):
    fig.update_xaxes(tickangle=-45, row=1, col=i)
    fig.update_yaxes(title_text="Days", row=1, col=i)

fig.show()

print("\n" + "=" * 60)
print("Team Analysis")
print("=" * 60)

team_stats = df[df['Team'] != 'Unassigned'].groupby('Team').agg({
    'Key': 'count',
    'totalCycleTime': 'mean',
    'activeDevelopmentTime': 'mean',
    'daysInBacklog': 'mean'
}).round(1)

team_stats.columns = ['Tickets', 'Cycle Time', 'Active Time', 'Backlog Time']
team_stats = team_stats[team_stats['Tickets'] >= 10]
team_stats = team_stats.sort_values('Cycle Time', ascending=False)

print("Top 10 teams by cycle time:")
print(team_stats.head(10))

fig = px.scatter(
    team_stats,
    x='Backlog Time',
    y='Active Time',
    size='Tickets',
    color='Cycle Time',
    hover_name=team_stats.index,
    title='Team Performance: Waiting Time vs Work Time',
    labels={
        'Backlog Time': 'Backlog Time (days)',
        'Active Time': 'Active Development Time (days)',
        'Cycle Time': 'Avg Cycle Time (days)'
    },
    color_continuous_scale='YlOrRd'
)

median_backlog = team_stats['Backlog Time'].median()
median_active = team_stats['Active Time'].median()

fig.add_hline(y=median_active, line_dash="dash", line_color="gray",
              annotation_text=f"Median Active Dev: {median_active:.1f}d")
fig.add_vline(x=median_backlog, line_dash="dash", line_color="gray",
              annotation_text=f"Median Backlog: {median_backlog:.1f}d")

fig.update_layout(height=600, width=1000)
fig.show()

q1 = team_stats[
    (team_stats['Backlog Time'] < median_backlog) &
    (team_stats['Active Time'] < median_active)
]
q2 = team_stats[
    (team_stats['Backlog Time'] >= median_backlog) &
    (team_stats['Active Time'] < median_active)
]
q3 = team_stats[
    (team_stats['Backlog Time'] < median_backlog) &
    (team_stats['Active Time'] >= median_active)
]
q4 = team_stats[
    (team_stats['Backlog Time'] >= median_backlog) &
    (team_stats['Active Time'] >= median_active)
]

print("\nQuadrant Analysis:")
if len(q1) > 0:
    print(f"\nLow Wait, Low Active ({len(q1)} teams):")
    print(f"  Avg cycle time: {q1['Cycle Time'].mean():.1f} days")
    print(f"  Examples: {', '.join(q1.index.tolist()[:5])}")

if len(q2) > 0:
    print(f"\nHigh Wait, Low Active ({len(q2)} teams):")
    print(f"  Avg cycle time: {q2['Cycle Time'].mean():.1f} days")
    print(f"  Examples: {', '.join(q2.index.tolist()[:5])}")

if len(q3) > 0:
    print(f"\nLow Wait, High Active ({len(q3)} teams):")
    print(f"  Avg cycle time: {q3['Cycle Time'].mean():.1f} days")
    print(f"  Examples: {', '.join(q3.index.tolist()[:5])}")

if len(q4) > 0:
    print(f"\nHigh Wait, High Active ({len(q4)} teams):")
    print(f"  Avg cycle time: {q4['Cycle Time'].mean():.1f} days")
    print(f"  Examples: {', '.join(q4.index.tolist()[:5])}")

print(f"\nNote: 'Unassigned' team excluded from analysis ({len(df[df['Team'] == 'Unassigned'])} tickets)")

priority_stats = df.groupby('Priority_clean').agg({
    'Key': 'count',
    'totalCycleTime': 'mean',
    'daysInBacklog': 'mean'
}).round(1)

priority_stats.columns = ['Count', 'Cycle Time', 'Backlog Time']

print("Performance by Priority Level:")
print(priority_stats)

fig = make_subplots(rows=1, cols=2,
                    subplot_titles=('Avg Cycle Time', 'Ticket Volume'))

fig.add_trace(
    go.Bar(x=priority_stats.index, y=priority_stats['Cycle Time'],
           marker_color='indianred', text=priority_stats['Cycle Time'],
           texttemplate='%{text:.1f}d'),
    row=1, col=1
)

fig.add_trace(
    go.Bar(x=priority_stats.index, y=priority_stats['Count'],
           marker_color='lightsalmon', text=priority_stats['Count']),
    row=1, col=2
)

fig.update_layout(height=400, showlegend=False, title_text="Priority Analysis")
fig.update_yaxes(title_text="Days", row=1, col=1)
fig.update_yaxes(title_text="Tickets", row=1, col=2)
fig.show()

blocked = df[df['daysBlocked'] > 0].copy()

print(f"Blocked ticket stats:")
print(f"  {len(blocked):,} tickets were blocked ({len(blocked)/len(df)*100:.1f}%)")
print(f"  Average blocked time: {blocked['daysBlocked'].mean():.1f} days")
print(f"  Median: {blocked['daysBlocked'].median():.1f} days")
print(f"  Longest: {blocked['daysBlocked'].max():.1f} days")

print("\nWorst offenders:")
worst_blocked = blocked.nlargest(10, 'daysBlocked')[['Key', 'Team', 'Priority', 'daysBlocked']]
print(worst_blocked.to_string(index=False))

fig = px.histogram(blocked[blocked['daysBlocked'] < 100],
                   x='daysBlocked', nbins=50,
                   title='Distribution of Blocking Time (< 100 days shown)',
                   labels={'daysBlocked': 'Days Blocked'},
                   color_discrete_sequence=['crimson'])
fig.add_vline(x=blocked['daysBlocked'].median(), line_dash="dash",
              annotation_text=f"Median: {blocked['daysBlocked'].median():.1f}d")
fig.update_layout(height=400)
fig.show()

blocked_by_team = blocked.groupby('Team').agg({
    'Key': 'count',
    'daysBlocked': 'mean'
}).round(1)
blocked_by_team.columns = ['Times Blocked', 'Avg Days']
print("\nTeams with most blocking issues:")
print(blocked_by_team.sort_values('Avg Days', ascending=False).head(10))

sprint_stats = df.groupby('NumSprints').agg({
    'Key': 'count',
    'totalCycleTime': 'mean'
}).round(1)
sprint_stats.columns = ['Count', 'Avg Cycle Time']

print("Tickets by number of sprints:")
print(sprint_stats.head(10))

fig = px.bar(sprint_stats[sprint_stats.index <= 6].reset_index(),
             x='NumSprints', y='Avg Cycle Time',
             color='Avg Cycle Time',
             color_continuous_scale='Reds',
             title='More Sprints = Longer Cycle Time',
             text='Avg Cycle Time')
fig.update_traces(texttemplate='%{text:.1f}d', textposition='outside')
fig.update_layout(height=400, showlegend=False)
fig.show()

sprint_dist = df['NumSprints'].value_counts().sort_index().head(10)
fig = px.bar(x=sprint_dist.index, y=sprint_dist.values,
             title='How Many Sprints Do Tickets Take?',
             labels={'x': 'Sprints', 'y': 'Number of Tickets'},
             color=sprint_dist.values,
             color_continuous_scale='Blues')
fig.update_layout(height=400, showlegend=False)
fig.show()

estimated = df[(df['Points'].notna()) & (df['ActualPoints'].notna())].copy()

estimated['accuracy'] = 'Accurate'
estimated.loc[estimated['ActualPoints'] > estimated['Points'], 'accuracy'] = 'Under-estimated'
estimated.loc[estimated['ActualPoints'] < estimated['Points'], 'accuracy'] = 'Over-estimated'

accuracy_counts = estimated['accuracy'].value_counts()
accuracy_pct = (accuracy_counts / len(estimated) * 100).round(1)

print("Estimation accuracy:")
for cat in accuracy_counts.index:
    print(f"  {cat}: {accuracy_counts[cat]:,} ({accuracy_pct[cat]}%)")

fig = px.pie(values=accuracy_counts.values, names=accuracy_counts.index,
             title='Story Point Estimation Accuracy',
             color_discrete_map={'Accurate': 'lightgreen',
                                 'Under-estimated': 'orange',
                                 'Over-estimated': 'lightblue'})
fig.update_traces(textposition='inside', textinfo='percent+label')
fig.show()

type_stats = df.groupby('Type').agg({
    'Key': 'count',
    'totalCycleTime': 'mean'
}).round(1)
type_stats.columns = ['Count', 'Avg Cycle Time']

print("Breakdown by ticket type:")
print(type_stats)

fig = make_subplots(rows=1, cols=2,
                    subplot_titles=('Cycle Time by Type', 'Volume by Type'),
                    specs=[[{"type": "bar"}, {"type": "pie"}]])

fig.add_trace(
    go.Bar(x=type_stats.index, y=type_stats['Avg Cycle Time'],
           marker_color='steelblue', text=type_stats['Avg Cycle Time'],
           texttemplate='%{text:.1f}d'),
    row=1, col=1
)

fig.add_trace(
    go.Pie(labels=type_stats.index, values=type_stats['Count'],
           textinfo='label+percent'),
    row=1, col=2
)

fig.update_layout(height=400, showlegend=False, title_text="Bug vs Story vs Task")
fig.update_yaxes(title_text="Days", row=1, col=1)
fig.show()

print("Time spent waiting in 'ready' states:")
print(f"  Ready for Review: {df['daysReadyReview'].mean():.2f} days")
print(f"  Ready for Test: {df['daysReadyForTest'].mean():.2f} days")

long_wait_review = df[df['daysReadyReview'] > 5]
long_wait_test = df[df['daysReadyForTest'] > 5]

print(f"\nTickets waiting over 5 days:")
print(f"  For review: {len(long_wait_review):,}")
print(f"  For test: {len(long_wait_test):,}")

fig = make_subplots(rows=1, cols=2,
                    subplot_titles=('Wait for Review', 'Wait for Test'))

fig.add_trace(
    go.Histogram(x=df[df['daysReadyReview'] < 10]['daysReadyReview'],
                 marker_color='coral', nbinsx=30),
    row=1, col=1
)

fig.add_trace(
    go.Histogram(x=df[df['daysReadyForTest'] < 10]['daysReadyForTest'],
                 marker_color='teal', nbinsx=30),
    row=1, col=2
)

fig.update_layout(height=400, showlegend=False,
                  title_text="Distribution of Wait Times")
fig.update_xaxes(title_text="Days", row=1, col=1)
fig.update_xaxes(title_text="Days", row=1, col=2)
fig.show()

df['month'] = df['Created'].dt.to_period('M')

# Filter out October
monthly = df[df['month'] != '2025-10'].groupby('month').agg({
    'Key': 'count',
    'totalCycleTime': 'mean'
}).round(1)
monthly.columns = ['Tickets', 'Avg Cycle Time']

fig = make_subplots(specs=[[{"secondary_y": True}]])

fig.add_trace(
    go.Bar(x=monthly.index.astype(str), y=monthly['Tickets'],
           name='Tickets Created', marker_color='lightblue'),
    secondary_y=False
)

fig.add_trace(
    go.Scatter(x=monthly.index.astype(str), y=monthly['Avg Cycle Time'],
               name='Avg Cycle Time', mode='lines+markers',
               line=dict(color='red', width=3)),
    secondary_y=True
)

fig.update_layout(title_text="Trends Over Time", height=500)
fig.update_xaxes(title_text="Month")
fig.update_yaxes(title_text="Tickets Created", secondary_y=False)
fig.update_yaxes(title_text="Cycle Time (days)", secondary_y=True)
fig.show()

print("=" * 60)
print("SUMMARY")
print("=" * 60)
print(f"\nBiggest bottleneck: Backlog ({df['daysInBacklog'].mean():.1f} days avg)")
print(f"Slowest teams: {', '.join(team_stats.head(3).index)}")
print(f"Blocked tickets: {len(blocked):,} ({len(blocked)/len(df)*100:.1f}%)")
print(f"Multi-sprint tickets: {len(df[df['NumSprints'] > 1]):,} ({len(df[df['NumSprints'] > 1])/len(df)*100:.1f}%)")
print(f"No sprint assigned: {len(df[df['NumSprints'] == 0]):,} tickets")
print(f"\nMedian cycle time: {df['totalCycleTime'].median():.1f} days")
print(f"90th percentile: {df['totalCycleTime'].quantile(0.9):.1f} days")

# Calculate New Metrics

df['totalWaitTime'] = (df['daysReadyReview'] +
                       df['daysReadyForTest'] +
                       df['daysBlocked'])

df['cycleTimeExcludingBacklog'] = df['totalCycleTime'] - df['daysInBacklog']

print(f"\nNew Metrics Summary:")
print(f"  Average wait time: {df['totalWaitTime'].mean():.1f} days")
print(f"  Average active development: {df['activeDevelopmentTime'].mean():.1f} days")
print(f"  Average cycle (ex. backlog): {df['cycleTimeExcludingBacklog'].mean():.1f} days")


# Cycle Time Breakdown by Type
print("\nActive Development Cycle Time by Ticket Type")
print("=" * 60)

stage_order = ['In Progress', 'Ready for Review', 'In Review',
               'Ready for Test', 'In Test', 'In CI', 'Blocked']

ticket_types = ['Bug', 'Story', 'Task']
colors_by_type = {'Bug': '#D32F2F', 'Story': '#1976D2', 'Task': '#2E7D32'}

fig = make_subplots(
    rows=1, cols=3,
    subplot_titles=[f'{t} (n={len(df[df["Type"]==t]):,})' for t in ticket_types],
    specs=[[{"type": "waterfall"}, {"type": "waterfall"}, {"type": "waterfall"}]]
)

for idx, ticket_type in enumerate(ticket_types):
    type_df = df[df['Type'] == ticket_type]

    stages = {
        'In Progress': type_df['daysInProgress'].mean(),
        'Ready for Review': type_df['daysReadyReview'].mean(),
        'In Review': type_df['daysInReview'].mean(),
        'Ready for Test': type_df['daysReadyForTest'].mean(),
        'In Test': type_df['daysInTest'].mean(),
        'In CI': type_df['daysInCI'].mean(),
        'Blocked': type_df['daysBlocked'].mean()
    }

    stages_ordered = {stage: stages[stage] for stage in stage_order}

    fig.add_trace(
        go.Waterfall(
            orientation="v",
            measure=["relative"] * len(stages_ordered),
            x=list(stages_ordered.keys()),
            y=list(stages_ordered.values()),
            text=[f"{v:.1f}d" for v in stages_ordered.values()],
            textposition="outside",
            connector={"line": {"color": "rgb(63, 63, 63)"}},
            increasing={"marker": {"color": colors_by_type[ticket_type]}},
            showlegend=False
        ),
        row=1, col=idx+1
    )

    total = sum(stages_ordered.values())
    print(f"\n{ticket_type}:")
    for stage, days in stages_ordered.items():
        pct = (days / total * 100) if total > 0 else 0
        print(f"  {stage:20s} {days:6.1f} days ({pct:4.1f}%)")

fig.update_layout(
    title="Active Development Cycle Time by Ticket Type<br><sub>(Backlog time excluded)</sub>",
    height=500
)
fig.update_yaxes(title_text="Days")
fig.show()


# Team Performance - Wait Time vs Active Development
print("\nTeam Performance Analysis")
print("=" * 60)

team_stats = pd.DataFrame()

for team in df['Team'].unique():
    if team == 'Unassigned':
        continue

    team_df = df[df['Team'] == team]

    team_stats.loc[team, 'Tickets'] = len(team_df)
    team_stats.loc[team, 'waitTime'] = team_df['totalWaitTime'].mean()
    team_stats.loc[team, 'activeTime'] = team_df['activeDevelopmentTime'].mean()
    team_stats.loc[team, 'cycleTime'] = team_df['totalCycleTime'].mean()

team_stats = team_stats[team_stats['Tickets'] >= 10].copy()

fig = px.scatter(
    team_stats,
    x='waitTime',
    y='activeTime',
    size='Tickets',
    color='cycleTime',
    hover_name=team_stats.index,
    hover_data={
        'waitTime': ':.1f',
        'activeTime': ':.1f',
        'cycleTime': ':.1f',
        'Tickets': ':,',
    },
    labels={
        'waitTime': 'Wait Time (days)',
        'activeTime': 'Active Development Time (days)',
        'cycleTime': 'Avg Cycle Time (days)'
    },
    title='Team Performance: Wait Time vs Active Development<br><sub>Wait Time = Ready for Review + Ready for Test + Blocked</sub>',
    color_continuous_scale='YlOrRd',
    size_max=60
)

median_wait = team_stats['waitTime'].median()
median_active = team_stats['activeTime'].median()

fig.add_hline(y=median_active, line_dash="dash", line_color="gray",
              annotation_text=f"Median Active: {median_active:.1f}d")
fig.add_vline(x=median_wait, line_dash="dash", line_color="gray",
              annotation_text=f"Median Wait: {median_wait:.1f}d")

fig.update_layout(height=600, width=1000)
fig.show()

print(f"\nMedian wait time: {median_wait:.1f} days")
print(f"Median active development: {median_active:.1f} days")
print(f"\nTeams with highest wait time:")
print(team_stats.nlargest(5, 'waitTime')[['waitTime', 'activeTime', 'Tickets']])


# Stage Comparison by Ticket Type
print("\nStage Duration Comparison Across Ticket Types")
print("=" * 60)

stages_to_compare = ['daysInProgress', 'daysReadyReview', 'daysInReview',
                     'daysReadyForTest', 'daysInTest', 'daysInCI', 'daysBlocked']

stage_labels = {
    'daysInProgress': 'In Progress',
    'daysInReview': 'In Review',
    'daysInTest': 'In Test',
    'daysInCI': 'In CI',
    'daysReadyReview': 'Ready for Review',
    'daysReadyForTest': 'Ready for Test',
    'daysBlocked': 'Blocked'
}

comparison_data = []
for ticket_type in df['Type'].unique():
    type_df = df[df['Type'] == ticket_type]
    for stage_col in stages_to_compare:
        comparison_data.append({
            'Type': ticket_type,
            'Stage': stage_labels[stage_col],
            'Days': type_df[stage_col].mean()
        })

comparison_df = pd.DataFrame(comparison_data)

comparison_df['Stage'] = pd.Categorical(
    comparison_df['Stage'],
    categories=[stage_labels[s] for s in stages_to_compare],
    ordered=True
)

fig = px.bar(
    comparison_df.sort_values('Stage'),
    x='Stage',
    y='Days',
    color='Type',
    barmode='group',
    title='Average Stage Duration by Ticket Type',
    labels={'Days': 'Average Days'},
    color_discrete_map={'Bug': '#D32F2F', 'Story': '#1976D2', 'Task': '#2E7D32'}
)

fig.update_layout(height=500, xaxis_tickangle=-45)
fig.show()

pivot = comparison_df.pivot(index='Stage', columns='Type', values='Days')
pivot['Range'] = pivot.max(axis=1) - pivot.min(axis=1)
pivot = pivot.sort_values('Range', ascending=False)

print("\nStages with largest variation between ticket types:")
for stage in pivot.head(5).index:
    print(f"\n{stage}:")
    for ticket_type in ['Bug', 'Story', 'Task']:
        print(f"  {ticket_type:8s}: {pivot.loc[stage, ticket_type]:6.1f} days")
    print(f"  Range: {pivot.loc[stage, 'Range']:.1f} days")


# Wait Time Breakdown
print("\nWait Time Breakdown")
print("=" * 60)

wait_components = {
    'Ready for Review': df['daysReadyReview'].mean(),
    'Ready for Test': df['daysReadyForTest'].mean(),
    'Blocked': df['daysBlocked'].mean()
}

fig = px.pie(
    values=list(wait_components.values()),
    names=list(wait_components.keys()),
    title='Where Does Wait Time Come From?',
    color_discrete_sequence=['#FF6B6B', '#FFA502', '#845EC2']
)
fig.update_traces(textposition='inside', textinfo='label+value',
                  texttemplate='%{label}<br>%{value:.1f}d')
fig.show()

total_wait = sum(wait_components.values())
print("\nWait time breakdown:")
for component, days in wait_components.items():
    pct = (days / total_wait * 100) if total_wait > 0 else 0
    print(f"  {component:20s}: {days:.1f} days ({pct:.1f}%)")


# Priority Analysis - Active Development
print("\nActive Development by Priority")
print("=" * 60)

df['Priority_clean'] = df['Priority'].str.strip()

priority_stats = df.groupby('Priority_clean').agg({
    'Key': 'count',
    'activeDevelopmentTime': 'mean',
    'totalWaitTime': 'mean',
    'cycleTimeExcludingBacklog': 'mean'
}).round(1)

priority_stats.columns = ['Count', 'Active Dev', 'Wait Time', 'Cycle (ex. backlog)']
priority_stats = priority_stats.sort_index()

print("\nPerformance by Priority Level:")
print(priority_stats)

fig = make_subplots(
    rows=1, cols=3,
    subplot_titles=('Active Development Time', 'Wait Time', 'Ticket Volume')
)

fig.add_trace(
    go.Bar(x=priority_stats.index, y=priority_stats['Active Dev'],
           marker_color='#1976D2', text=priority_stats['Active Dev'],
           texttemplate='%{text:.1f}d', name='Active Dev'),
    row=1, col=1
)

fig.add_trace(
    go.Bar(x=priority_stats.index, y=priority_stats['Wait Time'],
           marker_color='#FFA502', text=priority_stats['Wait Time'],
           texttemplate='%{text:.1f}d', name='Wait Time'),
    row=1, col=2
)

fig.add_trace(
    go.Bar(x=priority_stats.index, y=priority_stats['Count'],
           marker_color='#2E7D32', text=priority_stats['Count'],
           texttemplate='%{text:,}', name='Count'),
    row=1, col=3
)

fig.update_layout(height=400, showlegend=False, title_text="Priority Analysis")
fig.update_yaxes(title_text="Days", row=1, col=1)
fig.update_yaxes(title_text="Days", row=1, col=2)
fig.update_yaxes(title_text="Tickets", row=1, col=3)
fig.show()


# Priority by Type Heatmap
print("\nActive Development Time by Type and Priority")
print("=" * 60)

heatmap_data = []
for ticket_type in df['Type'].unique():
    for priority in ['Highest', 'High', 'Medium', 'Low', 'Lowest']:
        subset = df[(df['Type'] == ticket_type) & (df['Priority_clean'] == priority)]
        if len(subset) >= 5:
            heatmap_data.append({
                'Type': ticket_type,
                'Priority': priority,
                'Active Dev': subset['activeDevelopmentTime'].mean(),
                'Wait Time': subset['totalWaitTime'].mean(),
                'Count': len(subset)
            })

heatmap_df = pd.DataFrame(heatmap_data)

pivot_active = heatmap_df.pivot(index='Priority', columns='Type', values='Active Dev')
pivot_active = pivot_active.reindex(['Highest', 'High', 'Medium', 'Low', 'Lowest'])

fig = go.Figure(data=go.Heatmap(
    z=pivot_active.values,
    x=pivot_active.columns,
    y=pivot_active.index,
    colorscale='RdYlGn_r',
    text=np.round(pivot_active.values, 1),
    texttemplate='%{text}d',
    textfont={"size": 12},
    colorbar=dict(title="Days")
))

fig.update_layout(
    title='Active Development Time by Type & Priority',
    xaxis_title='Ticket Type',
    yaxis_title='Priority',
    height=400
)
fig.show()

print("\nActive Development Time (days):")
print(pivot_active.round(1))


# Priority Performance Over Time
print("\nPriority Performance Trends")
print("=" * 60)

df['month'] = df['Created'].dt.to_period('M')
df_filtered = df[df['month'] != '2025-10'].copy()

monthly_priority = df_filtered.groupby(['month', 'Priority_clean']).agg({
    'activeDevelopmentTime': 'mean',
    'totalWaitTime': 'mean',
    'Key': 'count'
}).round(1)
monthly_priority.columns = ['Active Dev', 'Wait Time', 'Count']
monthly_priority = monthly_priority.reset_index()
monthly_priority['month_str'] = monthly_priority['month'].astype(str)

main_priorities = ['Highest', 'High', 'Medium', 'Low']
monthly_priority = monthly_priority[monthly_priority['Priority_clean'].isin(main_priorities)]

fig = px.line(
    monthly_priority,
    x='month_str',
    y='Active Dev',
    color='Priority_clean',
    title='Active Development Time by Priority Over Time',
    labels={'month_str': 'Month', 'Active Dev': 'Average Active Dev Time (days)',
            'Priority_clean': 'Priority'},
    markers=True
)

fig.update_layout(height=500, xaxis_tickangle=-45)
fig.show()

fig = px.area(
    monthly_priority,
    x='month_str',
    y='Count',
    color='Priority_clean',
    title='Ticket Volume by Priority Over Time',
    labels={'month_str': 'Month', 'Count': 'Number of Tickets',
            'Priority_clean': 'Priority'}
)

fig.update_layout(height=500, xaxis_tickangle=-45)
fig.show()


# Cycle Time Trends by Type
print("\nCycle Time Trends by Ticket Type Over Time")
print("=" * 60)

df_filtered = df[df['month'] != '2025-10'].copy()

monthly_by_type = df_filtered.groupby(['month', 'Type']).agg({
    'activeDevelopmentTime': 'mean',
    'totalWaitTime': 'mean',
    'Key': 'count'
}).round(1)
monthly_by_type.columns = ['Active Dev', 'Wait Time', 'Count']
monthly_by_type = monthly_by_type.reset_index()
monthly_by_type['month_str'] = monthly_by_type['month'].astype(str)

fig = px.line(
    monthly_by_type,
    x='month_str',
    y='Active Dev',
    color='Type',
    title='Active Development Time Trends by Type',
    labels={'month_str': 'Month', 'Active Dev': 'Average Active Dev Time (days)'},
    color_discrete_map={'Bug': '#D32F2F', 'Story': '#1976D2', 'Task': '#2E7D32'},
    markers=True
)

fig.update_layout(height=500, xaxis_tickangle=-45)
fig.show()

fig = px.line(
    monthly_by_type,
    x='month_str',
    y='Wait Time',
    color='Type',
    title='Wait Time Trends by Type',
    labels={'month_str': 'Month', 'Wait Time': 'Average Wait Time (days)'},
    color_discrete_map={'Bug': '#D32F2F', 'Story': '#1976D2', 'Task': '#2E7D32'},
    markers=True
)

fig.update_layout(height=500, xaxis_tickangle=-45)
fig.show()


# Priority Distribution by Type
print("\nPriority Distribution by Ticket Type")
print("=" * 60)

priority_type_counts = df.groupby(['Type', 'Priority_clean']).size().reset_index(name='Count')
priority_type_counts = priority_type_counts[priority_type_counts['Priority_clean'].isin(main_priorities)]

fig = px.bar(
    priority_type_counts,
    x='Type',
    y='Count',
    color='Priority_clean',
    title='Priority Distribution by Ticket Type',
    labels={'Count': 'Number of Tickets', 'Priority_clean': 'Priority'},
    color_discrete_map={
        'Highest': '#8B0000',
        'High': '#FF6B6B',
        'Medium': '#FFD93D',
        'Low': '#6BCB77'
    },
    barmode='stack'
)

fig.update_layout(height=500)
fig.show()

print("\nPriority distribution by type:")
for ticket_type in df['Type'].unique():
    type_df = df[df['Type'] == ticket_type]
    print(f"\n{ticket_type}:")
    for priority in main_priorities:
        count = len(type_df[type_df['Priority_clean'] == priority])
        pct = (count / len(type_df) * 100)
        print(f"  {priority:10s}: {count:5,} ({pct:5.1f}%)")


# Summary Statistics
print("=" * 60)
print("SUMMARY - ACTIVE DEVELOPMENT FOCUS")
print("=" * 60)

avg_active = df['activeDevelopmentTime'].mean()
avg_wait = df['totalWaitTime'].mean()

active_stages = {
    'In Progress': df['daysInProgress'].mean(),
    'In Review': df['daysInReview'].mean(),
    'In Test': df['daysInTest'].mean(),
    'In CI': df['daysInCI'].mean(),
    'Blocked': df['daysBlocked'].mean(),
}
longest_stage = max(active_stages.items(), key=lambda x: x[1])

print(f"\nActive Development Metrics:")
print(f"  Average active dev time: {avg_active:.1f} days")
print(f"  Average wait time: {avg_wait:.1f} days")
print(f"  Longest active stage: {longest_stage[0]} ({longest_stage[1]:.1f} days)")

print(f"\nBy Ticket Type:")
for ticket_type in ['Bug', 'Story', 'Task']:
    type_df = df[df['Type'] == ticket_type]
    avg_type_active = type_df['activeDevelopmentTime'].mean()
    avg_type_wait = type_df['totalWaitTime'].mean()
    print(f"  {ticket_type:8s}: {avg_type_active:5.1f}d active | {avg_type_wait:5.1f}d wait")

print(f"\nBy Priority:")
for priority in ['Highest', 'High', 'Medium', 'Low']:
    priority_df = df[df['Priority_clean'] == priority]
    if len(priority_df) > 0:
        avg_priority_active = priority_df['activeDevelopmentTime'].mean()
        avg_priority_wait = priority_df['totalWaitTime'].mean()
        count = len(priority_df)
        print(f"  {priority:10s}: {avg_priority_active:5.1f}d active | {avg_priority_wait:5.1f}d wait | {count:5,} tickets")

print(f"\nTeam Performance:")
print(f"  Teams with longest wait times: {', '.join(team_stats.nlargest(3, 'waitTime').index)}")
print(f"  Teams with longest active dev: {', '.join(team_stats.nlargest(3, 'activeTime').index)}")

blocked = df[df['daysBlocked'] > 0]
print(f"\nProcess Issues:")
print(f"  Blocked tickets: {len(blocked):,} ({len(blocked)/len(df)*100:.1f}%)")
print(f"  Average blocked time: {blocked['daysBlocked'].mean():.1f} days")
print(f"  Multi-sprint tickets: {len(df[df['NumSprints'] > 1]):,} ({len(df[df['NumSprints'] > 1])/len(df)*100:.1f}%)")

print(f"\nOverall Metrics:")
print(f"  Median cycle time (ex. backlog): {df['cycleTimeExcludingBacklog'].median():.1f} days")
print(f"  90th percentile: {df['cycleTimeExcludingBacklog'].quantile(0.9):.1f} days")